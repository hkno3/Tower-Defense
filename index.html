<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>íƒ€ì›Œ ë””íœìŠ¤ Ultimate</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #0f0f23, #1a1a2e, #16213e);
            color: white;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: auto;
        }
        
        h1 {
            color: #4cc9f0;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #4cc9f0;
            font-size: 2.5em;
            text-align: center;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 20px #4cc9f0; }
            to { text-shadow: 0 0 30px #4cc9f0, 0 0 40px #7209b7; }
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #4cc9f0;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(76, 201, 240, 0.4);
            background: #16213e;
        }
        
        #gameCanvas {
            background: linear-gradient(45deg, #16213e, #1a1a2e);
            cursor: crosshair;
            border-radius: 12px;
        }
        
        #ui {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            font-size: 16px;
            max-width: 900px;
        }
        
        .stat {
            background: rgba(76, 201, 240, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #4cc9f0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .stat::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }
        
        .stat:hover::before {
            left: 100%;
        }
        
        #controls {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .tower-btn {
            padding: 12px 18px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            min-width: 90px;
            position: relative;
            overflow: hidden;
        }
        
        .tower-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, rgba(255,255,255,0.1), transparent);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .tower-btn:hover::before {
            opacity: 1;
        }
        
        .basic-tower { background: linear-gradient(45deg, #4cc9f0, #7209b7); }
        .sniper-tower { background: linear-gradient(45deg, #ff6b6b, #ee5a24); }
        .splash-tower { background: linear-gradient(45deg, #feca57, #ff9ff3); }
        .slow-tower { background: linear-gradient(45deg, #4ecdc4, #44bd87); }
        .laser-tower { background: linear-gradient(45deg, #a8e6cf, #ff8b94); }
        
        button {
            padding: 12px 20px;
            background: linear-gradient(45deg, #7209b7, #4cc9f0);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover, .tower-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(76, 201, 240, 0.4);
        }
        
        button:disabled, .tower-btn:disabled {
            background: #555 !important;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .selected {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.6);
            border: 2px solid white;
        }
        
        #gameOver, #towerInfo, #nextWaveInfo {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 2px solid #4cc9f0;
            max-width: 400px;
            backdrop-filter: blur(10px);
        }
        
        #towerInfo {
            top: 20%;
            background: rgba(22, 33, 62, 0.95);
        }
        
        #nextWaveInfo {
            top: 30%;
            background: rgba(22, 33, 62, 0.98);
        }
        
        .upgrade-btn {
            margin: 5px;
            padding: 8px 15px;
            font-size: 14px;
        }
        
        #skillBar {
            margin-top: 15px;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        
        .skill-btn {
            padding: 12px;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .skill-btn:hover {
            transform: scale(1.1);
            border-color: white;
        }
        
        .skill-cooldown {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }
        
        .cost {
            font-size: 12px;
            opacity: 0.9;
            background: rgba(0,0,0,0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }
        
        .buff-indicator {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffd700;
            color: #000;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            animation: bounce 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes bounce {
            from { transform: translateX(-50%) translateY(0); }
            to { transform: translateX(-50%) translateY(-3px); }
        }
        
        .achievement {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(45deg, #ffd700, #ffed4a);
            color: #000;
            padding: 15px 20px;
            border-radius: 10px;
            font-weight: bold;
            transform: translateX(300px);
            transition: transform 0.5s ease;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
        }
        
        .achievement.show {
            transform: translateX(0);
        }
        
        .damage-number {
            position: absolute;
            font-weight: bold;
            font-size: 14px;
            pointer-events: none;
            animation: damageFloat 1s ease-out forwards;
        }
        
        @keyframes damageFloat {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
        }
        
        .mini-map {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 120px;
            height: 80px;
            background: rgba(0,0,0,0.7);
            border: 1px solid #4cc9f0;
            border-radius: 5px;
        }
        
        .combo-counter {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .speed-controls {
            margin-top: 10px;
            display: flex;
            gap: 5px;
            justify-content: center;
        }
        
        .speed-btn {
            padding: 5px 10px;
            font-size: 12px;
            min-width: 40px;
        }
        
        .research-panel {
            background: rgba(22, 33, 62, 0.9);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            border: 1px solid #4cc9f0;
        }
        
        .research-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(76, 201, 240, 0.2);
        }
        
        .research-item:last-child {
            border-bottom: none;
        }
        
        .weather-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <h1>ğŸ° íƒ€ì›Œ ë””íœìŠ¤ ULTIMATE</h1>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        
        <div class="mini-map" id="miniMap">
            <canvas width="120" height="80"></canvas>
        </div>
        
        <div class="combo-counter" id="comboCounter" style="display: none;">
            ğŸ”¥ ì½¤ë³´: <span id="comboValue">0</span>
            <div style="font-size: 12px;">ë³´ë„ˆìŠ¤: +<span id="comboBonus">0</span>%</div>
        </div>
        
        <canvas class="weather-effect" id="weatherCanvas" width="900" height="600"></canvas>
        
        <div id="gameOver">
            <h2 id="gameOverTitle">ê²Œì„ ì˜¤ë²„!</h2>
            <p id="gameOverMessage"></p>
            <div id="finalStats"></div>
            <button onclick="restartGame()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
        
        <div id="towerInfo">
            <h3 id="towerTitle">íƒ€ì›Œ ì •ë³´</h3>
            <div id="towerStats"></div>
            <div id="towerUpgrades"></div>
            <button onclick="closeTowerInfo()">Close</button>
            <button onclick="sellTower()" style="background: linear-gradient(45deg, #ff6b6b, #ee5a24); margin-left: 10px;">Sell</button>
        </div>
        
        <div id="nextWaveInfo">
            <h3>ë‹¤ìŒ ì›¨ì´ë¸Œ ì •ë³´</h3>
            <div id="wavePreview"></div>
            <button onclick="closeWaveInfo()">ë‹«ê¸°</button>
        </div>
    </div>
    
    <div id="ui">
        <div class="stat">ğŸ’° <span id="gold">200</span></div>
        <div class="stat">â¤ï¸ <span id="lives">30</span></div>
        <div class="stat">ğŸŒŠ <span id="wave">1</span></div>
        <div class="stat">ğŸ‘¹ <span id="enemiesLeft">0</span></div>
        <div class="stat">ğŸ¯ <span id="score">0</span></div>
        <div class="stat">ğŸ’ <span id="research">0</span></div>
        <div class="stat">ğŸ† <span id="achievements">0</span></div>
    </div>
    
    <div id="controls">
        <div class="tower-btn basic-tower" onclick="selectTower('basic')">
            ğŸ°<br><span class="cost">30G</span>
        </div>
        <div class="tower-btn sniper-tower" onclick="selectTower('sniper')">
            ğŸ¯<br><span class="cost">60G</span>
        </div>
        <div class="tower-btn splash-tower" onclick="selectTower('splash')">
            ğŸ’¥<br><span class="cost">80G</span>
        </div>
        <div class="tower-btn slow-tower" onclick="selectTower('slow')">
            ğŸ§Š<br><span class="cost">50G</span>
        </div>
        <div class="tower-btn laser-tower" onclick="selectTower('laser')">
            âš¡<br><span class="cost">120G</span>
        </div>
        <button id="startWaveBtn" onclick="startWave()">ì›¨ì´ë¸Œ ì‹œì‘</button>
        <button onclick="pauseGame()">ì¼ì‹œì •ì§€</button>
        <button onclick="showWaveInfo()">ì›¨ì´ë¸Œ ì •ë³´</button>
    </div>
    
    <div class="speed-controls">
        <button class="speed-btn" onclick="setGameSpeed(0.5)">0.5x</button>
        <button class="speed-btn" onclick="setGameSpeed(1)" style="background: linear-gradient(45deg, #4ecdc4, #44bd87);">1x</button>
        <button class="speed-btn" onclick="setGameSpeed(2)">2x</button>
        <button class="speed-btn" onclick="setGameSpeed(4)">4x</button>
    </div>
    
    <div id="skillBar">
        <div class="skill-btn" style="background: linear-gradient(45deg, #ff6b6b, #ee5a24);" onclick="useSkill('bomb')" title="í­íƒ„ (100G)">
            ğŸ’£
            <div id="bombCooldown" class="skill-cooldown" style="display: none;"></div>
        </div>
        <div class="skill-btn" style="background: linear-gradient(45deg, #4ecdc4, #44bd87);" onclick="useSkill('freeze')" title="ë¹™ê²° (80G)">
            â„ï¸
            <div id="freezeCooldown" class="skill-cooldown" style="display: none;"></div>
        </div>
        <div class="skill-btn" style="background: linear-gradient(45deg, #feca57, #ff9ff3);" onclick="useSkill('boost')" title="ê°•í™” (60G)">
            âš¡
            <div id="boostCooldown" class="skill-cooldown" style="display: none;"></div>
        </div>
        <div class="skill-btn" style="background: linear-gradient(45deg, #a8e6cf, #ffd3a5);" onclick="useSkill('storm')" title="ë²ˆê°œ í­í’ (150G)">
            ğŸŒ©ï¸
            <div id="stormCooldown" class="skill-cooldown" style="display: none;"></div>
        </div>
    </div>
    
    <div class="research-panel">
        <h4 style="margin-top: 0; color: #4cc9f0;">ğŸ”¬ ì—°êµ¬ ì—…ê·¸ë ˆì´ë“œ</h4>
        <div class="research-item">
            <span>ğŸ’° ê³¨ë“œ ë³´ë„ˆìŠ¤ (+20%)</span>
            <button onclick="buyResearch('goldBonus')" id="goldBonusBtn">500ğŸ’</button>
        </div>
        <div class="research-item">
            <span>â¤ï¸ ë¼ì´í”„ ì¦ê°€ (+10)</span>
            <button onclick="buyResearch('moreLife')" id="moreLifeBtn">400ğŸ’</button>
        </div>
        <div class="research-item">
            <span>ğŸ° íƒ€ì›Œ ë°ë¯¸ì§€ (+25%)</span>
            <button onclick="buyResearch('towerDamage')" id="towerDamageBtn">600ğŸ’</button>
        </div>
        <div class="research-item">
            <span>âš¡ íƒ€ì›Œ ì†ë„ (+30%)</span>
            <button onclick="buyResearch('towerSpeed')" id="towerSpeedBtn">600ğŸ’</button>
        </div>
    </div>

    <div class="achievement" id="achievementNotification"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const miniMapCanvas = document.querySelector('.mini-map canvas');
        const miniMapCtx = miniMapCanvas.getContext('2d');
        const weatherCanvas = document.getElementById('weatherCanvas');
        const weatherCtx = weatherCanvas.getContext('2d');
        
        // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸
        let audioContext;
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        // ê²Œì„ ìƒíƒœ (ì—°êµ¬ ì‹œìŠ¤í…œ ìˆ˜ì •)
        let gameState = {
            gold: 200,
            lives: 30,
            wave: 1,
            score: 0,
            research: 0, // ì—°êµ¬ í¬ì¸íŠ¸ (ìˆ«ì)
            achievements: 0,
            selectedTool: null,
            selectedTower: null,
            paused: false,
            gameOver: false,
            gameSpeed: 1,
            combo: 0,
            maxCombo: 0,
            comboTimer: 0,
            weather: 'clear',
            weatherTimer: 0,
            totalKills: 0,
            totalDamage: 0,
            towersBuilt: 0,
            skills: {
                bomb: { cooldown: 0, cost: 100 },
                freeze: { cooldown: 0, cost: 80 },
                boost: { cooldown: 0, cost: 60 },
                storm: { cooldown: 0, cost: 150 }
            },
            researchUpgrades: { // ì—°êµ¬ ì—…ê·¸ë ˆì´ë“œ ìƒíƒœ (ë³„ë„ ê°ì²´)
                goldBonus: false,
                moreLife: false,
                towerDamage: false,
                towerSpeed: false
            },
            achievementsList: [
                { id: 'firstTower', name: 'ì²« íƒ€ì›Œ', desc: 'íƒ€ì›Œë¥¼ ì²˜ìŒ ê±´ì„¤í•˜ì„¸ìš”', unlocked: false },
                { id: 'wave10', name: 'ìƒì¡´ì', desc: 'ì›¨ì´ë¸Œ 10ì— ë„ë‹¬í•˜ì„¸ìš”', unlocked: false },
                { id: 'combo50', name: 'ì½¤ë³´ ë§ˆìŠ¤í„°', desc: '50 ì½¤ë³´ë¥¼ ë‹¬ì„±í•˜ì„¸ìš”', unlocked: false },
                { id: 'kill1000', name: 'í•™ì‚´ì', desc: 'ì  1000ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•˜ì„¸ìš”', unlocked: false },
                { id: 'noLife', name: 'ì™„ë²½í•œ ë°©ì–´', desc: 'ë¼ì´í”„ë¥¼ í•˜ë‚˜ë„ ìƒì§€ ì•Šê³  ì›¨ì´ë¸Œ 5ë¥¼ í´ë¦¬ì–´í•˜ì„¸ìš”', unlocked: false }
            ]
        };
        
        // ë‹¤ì–‘í•œ ë§µ ê²½ë¡œ ì •ì˜
        const mapPaths = {
            forest: [ // ê¸°ë³¸ ìˆ² ë§µ
                {x: 0, y: 300},
                {x: 150, y: 300},
                {x: 150, y: 200},
                {x: 300, y: 200},
                {x: 300, y: 400},
                {x: 500, y: 400},
                {x: 500, y: 150},
                {x: 700, y: 150},
                {x: 700, y: 350},
                {x: 900, y: 350}
            ],
            desert: [ // ì‚¬ë§‰ ë§µ (ì§ì„ ì )
                {x: 0, y: 250},
                {x: 200, y: 250},
                {x: 200, y: 450},
                {x: 400, y: 450},
                {x: 400, y: 150},
                {x: 600, y: 150},
                {x: 600, y: 350},
                {x: 800, y: 350},
                {x: 800, y: 200},
                {x: 900, y: 200}
            ],
            mountain: [ // ì‚°ì•… ë§µ (êµ¬ë¶ˆêµ¬ë¶ˆ)
                {x: 0, y: 400},
                {x: 100, y: 350},
                {x: 200, y: 250},
                {x: 350, y: 200},
                {x: 450, y: 300},
                {x: 550, y: 250},
                {x: 650, y: 350},
                {x: 750, y: 300},
                {x: 850, y: 250},
                {x: 900, y: 200}
            ],
            swamp: [ // ëŠªì§€ ë§µ (ë³µì¡í•œ ê²½ë¡œ)
                {x: 0, y: 200},
                {x: 120, y: 200},
                {x: 120, y: 400},
                {x: 250, y: 400},
                {x: 250, y: 100},
                {x: 400, y: 100},
                {x: 400, y: 350},
                {x: 550, y: 350},
                {x: 550, y: 150},
                {x: 700, y: 150},
                {x: 700, y: 450},
                {x: 900, y: 450}
            ],
            ice: [ // ì–¼ìŒ ë§µ (ê¸´ ì§ì„  êµ¬ê°„)
                {x: 0, y: 150},
                {x: 300, y: 150},
                {x: 300, y: 350},
                {x: 600, y: 350},
                {x: 600, y: 250},
                {x: 900, y: 250}
            ]
        };
        
        // ë§µ í…Œë§ˆë³„ ë°°ê²½ìƒ‰ê³¼ íŠ¹ì„±
        const mapThemes = {
            forest: {
                name: 'ìˆ²',
                backgroundColor: 'linear-gradient(45deg, #2d5016, #3a5f1f)',
                pathColor: 'rgba(139, 69, 19, 0.3)',
                treeTypes: ['tree', 'bush'],
                treeColors: ['#228B22', '#32CD32', '#90EE90'],
                treeCount: 40
            },
            desert: {
                name: 'ì‚¬ë§‰',
                backgroundColor: 'linear-gradient(45deg, #daa520, #f4a460)',
                pathColor: 'rgba(160, 82, 45, 0.4)',
                treeTypes: ['cactus', 'rock'],
                treeColors: ['#9acd32', '#8fbc8f', '#daa520'],
                treeCount: 25
            },
            mountain: {
                name: 'ì‚°ì•…',
                backgroundColor: 'linear-gradient(45deg, #696969, #2f4f4f)',
                pathColor: 'rgba(105, 105, 105, 0.4)',
                treeTypes: ['rock', 'pine'],
                treeColors: ['#708090', '#2f4f4f', '#556b2f'],
                treeCount: 30
            },
            swamp: {
                name: 'ëŠªì§€',
                backgroundColor: 'linear-gradient(45deg, #2f4f2f, #556b2f)',
                pathColor: 'rgba(85, 107, 47, 0.4)',
                treeTypes: ['swamptree', 'bush'],
                treeColors: ['#6b8e23', '#9acd32', '#8fbc8f'],
                treeCount: 35
            },
            ice: {
                name: 'ì–¼ìŒ',
                backgroundColor: 'linear-gradient(45deg, #b0e0e6, #87ceeb)',
                pathColor: 'rgba(135, 206, 235, 0.3)',
                treeTypes: ['icetree', 'crystal'],
                treeColors: ['#e0ffff', '#f0f8ff', '#87ceeb'],
                treeCount: 20
            }
        };
        
        // í˜„ì¬ ë§µ ì •ë³´
        let currentMap = 'forest';
        let path = mapPaths.forest;
        
        // ë§µ ë³€ê²½ í•¨ìˆ˜
        function changeMap() {
            let mapIndex = Math.floor((gameState.wave - 1) / 5);
            let mapNames = Object.keys(mapPaths);
            currentMap = mapNames[mapIndex % mapNames.length];
            path = mapPaths[currentMap];
            
            // ë°°ê²½ìƒ‰ ë³€ê²½
            let theme = mapThemes[currentMap];
            canvas.style.background = theme.backgroundColor;
            
            // ë‚˜ë¬´ë“¤ ë‹¤ì‹œ ìƒì„± (ìƒˆë¡œìš´ ë§µì— ë§ê²Œ)
            generateBackgroundTrees();
            
            // ë§µ ë³€ê²½ ì•Œë¦¼
            showMapChangeNotification(theme.name);
        }
        
        // ë§µ ë³€ê²½ ì•Œë¦¼
        function showMapChangeNotification(mapName) {
            let notification = document.getElementById('achievementNotification');
            notification.innerHTML = `
                <div style="font-size: 18px;">ğŸ—ºï¸ ìƒˆë¡œìš´ ì§€ì—­!</div>
                <div style="font-size: 14px; margin-top: 5px;">${mapName} ì§€ì—­ ì§„ì…</div>
                <div style="font-size: 12px; opacity: 0.8;">ìƒˆë¡œìš´ ì „ì¥ì—ì„œ ê³„ì† ì „íˆ¬í•˜ì„¸ìš”!</div>
            `;
            notification.style.background = 'linear-gradient(45deg, #32cd32, #90ee90)';
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
                notification.style.background = 'linear-gradient(45deg, #ffd700, #ffed4a)';
            }, 4000);
            
            playSound(800, 1, 'sine', 0.1);
        }
        
        // ê²Œì„ ê°ì²´ë“¤
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let effects = [];
        let damageNumbers = [];
        let weatherParticles = [];
        
        // ì›¨ì´ë¸Œ ê´€ë¦¬
        let currentWave = [];
        let waveStarted = false;
        let enemiesSpawned = 0;
        let spawnTimer = 0;
        
        // íƒ€ì›Œ íƒ€ì… ì •ì˜ (í•œêµ­ì–´ë¡œ ë³µì›)
        const towerTypes = {
            basic: {
                cost: 30,
                damage: 25,
                range: 100,
                fireRate: 60,
                projectileSpeed: 8,
                color: '#4cc9f0',
                name: 'ê¸°ë³¸ íƒ€ì›Œ',
                upgrades: [
                    { cost: 40, damage: 15, range: 20, fireRate: -10 },
                    { cost: 80, damage: 25, range: 30, fireRate: -15 }
                ]
            },
            sniper: {
                cost: 60,
                damage: 120,
                range: 220,
                fireRate: 120,
                projectileSpeed: 20,
                color: '#ff6b6b',
                name: 'ì €ê²© íƒ€ì›Œ',
                upgrades: [
                    { cost: 80, damage: 60, range: 50, fireRate: -20 },
                    { cost: 150, damage: 100, range: 100, fireRate: -30 }
                ]
            },
            splash: {
                cost: 80,
                damage: 45,
                range: 90,
                fireRate: 90,
                projectileSpeed: 6,
                splashRadius: 60,
                color: '#feca57',
                name: 'ìŠ¤í”Œë˜ì‹œ íƒ€ì›Œ',
                upgrades: [
                    { cost: 100, damage: 30, splashRadius: 25, fireRate: -15 },
                    { cost: 200, damage: 50, splashRadius: 35, fireRate: -25 }
                ]
            },
            slow: {
                cost: 50,
                damage: 20,
                range: 85,
                fireRate: 45,
                projectileSpeed: 12,
                slowEffect: 0.8,
                slowDuration: 180,
                color: '#4ecdc4',
                name: 'ë¹™ê²° íƒ€ì›Œ',
                upgrades: [
                    { cost: 60, slowEffect: -0.1, slowDuration: 60, range: 25 },
                    { cost: 120, slowEffect: -0.1, slowDuration: 120, damage: 30 }
                ]
            },
            laser: {
                cost: 120,
                damage: 15,
                range: 130,
                fireRate: 5,
                projectileSpeed: 30,
                piercing: 3,
                color: '#a8e6cf',
                name: 'ë ˆì´ì € íƒ€ì›Œ',
                upgrades: [
                    { cost: 150, damage: 10, piercing: 2, fireRate: -1 },
                    { cost: 300, damage: 20, piercing: 5, range: 50 }
                ]
            }
        };
        
        // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ í´ë˜ìŠ¤
        class DamageNumber {
            constructor(x, y, damage, critical = false) {
                this.x = x + (Math.random() - 0.5) * 20;
                this.y = y;
                this.damage = damage;
                this.critical = critical;
                this.life = 60;
                this.vy = -2;
            }
            
            update() {
                this.y += this.vy;
                this.life--;
                
                if (this.life <= 0) {
                    let index = damageNumbers.indexOf(this);
                    if (index > -1) {
                        damageNumbers.splice(index, 1);
                    }
                }
            }
            
            draw() {
                let alpha = this.life / 60;
                ctx.fillStyle = this.critical ? 
                    `rgba(255, 215, 0, ${alpha})` : 
                    `rgba(255, 100, 100, ${alpha})`;
                ctx.font = this.critical ? 'bold 18px Arial' : 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(Math.round(this.damage), this.x, this.y);
            }
        }
        
        // í–¥ìƒëœ íƒ€ì›Œ í´ë˜ìŠ¤
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.level = 1;
                this.lastFired = 0;
                this.target = null;
                this.boostTimer = 0;
                this.kills = 0;
                this.totalDamage = 0;
                
                const baseStats = towerTypes[type];
                this.range = baseStats.range;
                this.damage = baseStats.damage;
                this.fireRate = baseStats.fireRate;
                this.projectileSpeed = baseStats.projectileSpeed;
                this.color = baseStats.color;
                this.splashRadius = baseStats.splashRadius || 0;
                this.slowEffect = baseStats.slowEffect || 0;
                this.slowDuration = baseStats.slowDuration || 0;
                this.piercing = baseStats.piercing || 0;
                
                // ì—°êµ¬ ë³´ë„ˆìŠ¤ ì ìš© (ìˆ˜ì •ë¨)
                if (gameState.researchUpgrades && gameState.researchUpgrades.towerDamage) {
                    this.damage *= 1.25;
                }
                if (gameState.researchUpgrades && gameState.researchUpgrades.towerSpeed) {
                    this.fireRate *= 0.7;
                }
            }
            
            update() {
                this.lastFired++;
                if (this.boostTimer > 0) {
                    this.boostTimer--;
                }
                
                this.findTarget();
                let currentFireRate = this.boostTimer > 0 ? this.fireRate * 0.4 : this.fireRate;
                currentFireRate /= gameState.gameSpeed;
                
                if (this.target && this.lastFired >= currentFireRate) {
                    this.fire();
                    this.lastFired = 0;
                }
            }
            
            findTarget() {
                this.target = null;
                let bestScore = -1;
                
                for (let enemy of enemies) {
                    let distance = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (distance <= this.range) {
                        // íƒ€ê²ŸíŒ… ìš°ì„ ìˆœìœ„: ì§„í–‰ë„ + ì²´ë ¥ ë¹„ìœ¨
                        let progress = enemy.pathIndex / path.length;
                        let healthRatio = enemy.hp / enemy.maxHp;
                        let score = progress * 100 + (1 - healthRatio) * 50;
                        
                        if (score > bestScore) {
                            this.target = enemy;
                            bestScore = score;
                        }
                    }
                }
            }
            
            fire() {
                if (this.target) {
                    let damage = this.boostTimer > 0 ? this.damage * 1.8 : this.damage;
                    
                    // ë‚ ì”¨ íš¨ê³¼
                    if (gameState.weather === 'storm') {
                        damage *= 1.2;
                    } else if (gameState.weather === 'fog') {
                        damage *= 0.8;
                    }
                    
                    // í¬ë¦¬í‹°ì»¬ íˆíŠ¸ (10% í™•ë¥ ë¡œ 2ë°° ë°ë¯¸ì§€)
                    let critical = Math.random() < 0.1;
                    if (critical) {
                        damage *= 2;
                    }
                    
                    projectiles.push(new Projectile(this.x, this.y, this.target, damage, this.type, this, critical));
                    playSound(800 + Math.random() * 200, 0.1, 'square', 0.05);
                }
            }
            
            upgrade() {
                const towerData = towerTypes[this.type];
                if (this.level <= towerData.upgrades.length) {
                    const upgrade = towerData.upgrades[this.level - 1];
                    if (gameState.gold >= upgrade.cost) {
                        gameState.gold -= upgrade.cost;
                        
                        this.damage += upgrade.damage || 0;
                        this.range += upgrade.range || 0;
                        this.fireRate += upgrade.fireRate || 0;
                        this.splashRadius += upgrade.splashRadius || 0;
                        this.slowEffect += upgrade.slowEffect || 0;
                        this.slowDuration += upgrade.slowDuration || 0;
                        this.piercing += upgrade.piercing || 0;
                        
                        this.level++;
                        playSound(1200, 0.3, 'sine');
                        return true;
                    }
                }
                return false;
            }
            
            getSellValue() {
                let value = towerTypes[this.type].cost * 0.8;
                for (let i = 0; i < this.level - 1; i++) {
                    value += towerTypes[this.type].upgrades[i].cost * 0.8;
                }
                return Math.floor(value);
            }
            
            draw() {
                // íƒ€ì›Œ ê¸°ë³¸ ëª¨ì–‘
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - 15, this.y - 15, 30, 30);
                
                // ì—…ê·¸ë ˆì´ë“œ ë ˆë²¨ í‘œì‹œ
                for (let i = 0; i < this.level - 1; i++) {
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(this.x - 12 + i * 8, this.y - 20, 6, 3);
                }
                
                // í‚¬ ìˆ˜ í‘œì‹œ (10í‚¬ ì´ìƒì¼ ë•Œ)
                if (this.kills >= 10) {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.kills, this.x, this.y - 25);
                }
                
                // íƒ€ì›Œ í¬íƒ‘
                ctx.fillStyle = this.boostTimer > 0 ? '#ffd700' : '#7209b7';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // ë¶€ìŠ¤íŠ¸ íš¨ê³¼ í‘œì‹œ
                if (this.boostTimer > 0) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 20, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.lineWidth = 1;
                }
                
                // íƒ€ì…ë³„ ì•„ì´ì½˜
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                let icon = this.type === 'sniper' ? 'ğŸ¯' : 
                          this.type === 'splash' ? 'ğŸ’¥' : 
                          this.type === 'slow' ? 'ğŸ§Š' :
                          this.type === 'laser' ? 'âš¡' : 'ğŸ°';
                ctx.fillText(icon, this.x, this.y + 5);
                
                // ì„ íƒëœ íƒ€ì›Œ ì‚¬ê±°ë¦¬ í‘œì‹œ
                if (gameState.selectedTower === this) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.setLineDash([8, 8]);
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.lineWidth = 1;
                }
                
                // ë°°ì¹˜ ì¤‘ì¸ íƒ€ì›Œì˜ ì‚¬ê±°ë¦¬ í‘œì‹œ
                if (gameState.selectedTool && gameState.selectedTool !== 'sell') {
                    let mousePos = getMousePos();
                    if (mousePos && towerTypes[gameState.selectedTool]) {
                        ctx.strokeStyle = 'rgba(76, 201, 240, 0.4)';
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(mousePos.x, mousePos.y, towerTypes[gameState.selectedTool].range, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }
        }
        
        // í–¥ìƒëœ ì  í´ë˜ìŠ¤
        class Enemy {
            constructor(type = 'basic') {
                this.x = path[0].x;
                this.y = path[0].y;
                this.pathIndex = 0;
                this.maxHp = 800;
                this.hp = this.maxHp;
                this.reward = 18;
                this.researchReward = 1;
                this.size = 15;
                this.baseSpeed = 1.2 + Math.random() * 0.4;
                this.speed = this.baseSpeed;
                this.slowTimer = 0;
                this.frozen = false;
                this.armor = 0;
                this.regeneration = 0;
                this.shield = 0;
                this.maxShield = 0;
                
                if (type === 'strong') {
                    this.maxHp = 2000;
                    this.hp = 2000;
                    this.reward = 35;
                    this.researchReward = 2;
                    this.baseSpeed *= 0.75;
                    this.speed = this.baseSpeed;
                    this.size = 20;
                    this.armor = 5;
                } else if (type === 'fast') {
                    this.maxHp = 600;
                    this.hp = 600;
                    this.reward = 25;
                    this.researchReward = 2;
                    this.baseSpeed *= 2.2;
                    this.speed = this.baseSpeed;
                    this.size = 12;
                } else if (type === 'boss') {
                    this.maxHp = 20000;
                    this.hp = 20000;
                    this.reward = 150;
                    this.researchReward = 10;
                    this.baseSpeed *= 0.5;
                    this.speed = this.baseSpeed;
                    this.size = 35;
                    this.armor = 15;
                    this.regeneration = 2;
                } else if (type === 'shielded') {
                    this.maxHp = 1000;
                    this.hp = 1000;
                    this.shield = 500;
                    this.maxShield = 500;
                    this.reward = 40;
                    this.researchReward = 3;
                    this.baseSpeed *= 0.9;
                    this.speed = this.baseSpeed;
                    this.size = 18;
                } else if (type === 'flying') {
                    this.maxHp = 600;
                    this.hp = 600;
                    this.reward = 30;
                    this.researchReward = 2;
                    this.baseSpeed *= 1.5;
                    this.speed = this.baseSpeed;
                    this.size = 14;
                    this.flying = true;
                }
                
                this.type = type;
            }
            
            update() {
                // ì¬ìƒ íš¨ê³¼
                if (this.regeneration > 0 && this.hp < this.maxHp) {
                    this.hp = Math.min(this.maxHp, this.hp + this.regeneration / 60);
                }
                
                // ìŠ¬ë¡œìš° íš¨ê³¼ ì²˜ë¦¬
                if (this.slowTimer > 0) {
                    this.slowTimer--;
                    if (this.slowTimer === 0) {
                        this.speed = this.baseSpeed;
                        this.frozen = false;
                    }
                }
                
                // ë¹™ê²° ìƒíƒœë©´ ì›€ì§ì´ì§€ ì•ŠìŒ
                if (this.frozen) return;
                
                // ì‹¤ì œ ì†ë„ì— ê²Œì„ ì†ë„ ì ìš©
                let actualSpeed = this.speed * gameState.gameSpeed;
                
                if (this.pathIndex < path.length - 1) {
                    let target = path[this.pathIndex + 1];
                    let dx = target.x - this.x;
                    let dy = target.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 8) {
                        this.pathIndex++;
                    } else {
                        this.x += (dx / distance) * actualSpeed;
                        this.y += (dy / distance) * actualSpeed;
                    }
                } else {
                    // ì ì´ ëê¹Œì§€ ë„ë‹¬
                    gameState.lives--;
                    this.remove();
                    playSound(300, 0.5, 'sawtooth');
                    
                    // ì½¤ë³´ ë¦¬ì…‹
                    gameState.combo = 0;
                    gameState.comboTimer = 0;
                }
            }
            
            takeDamage(damage, tower = null, critical = false) {
                // ì•„ë¨¸ ê³„ì‚°
                let actualDamage = Math.max(1, damage - this.armor);
                
                // ì‰´ë“œ ë¨¼ì € ê¹ê¸°
                if (this.shield > 0) {
                    let shieldDamage = Math.min(this.shield, actualDamage);
                    this.shield -= shieldDamage;
                    actualDamage -= shieldDamage;
                }
                
                // ì²´ë ¥ ê¹ê¸°
                if (actualDamage > 0) {
                    this.hp -= actualDamage;
                }
                
                // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ
                damageNumbers.push(new DamageNumber(this.x, this.y - this.size, damage, critical));
                
                if (tower) {
                    tower.totalDamage += damage;
                }
                
                gameState.totalDamage += damage;
                
                if (this.hp <= 0) {
                    // ë¦¬ì›Œë“œ ê³„ì‚°
                    let goldReward = this.reward;
                    let researchReward = this.researchReward;
                    
                    // ì½¤ë³´ ë³´ë„ˆìŠ¤
                    let comboBonus = Math.floor(gameState.combo / 10) * 0.1;
                    goldReward = Math.floor(goldReward * (1 + comboBonus));
                    
                    // ì—°êµ¬ ë³´ë„ˆìŠ¤ ì ìš© (ìˆ˜ì •ë¨)
                    if (gameState.researchUpgrades && gameState.researchUpgrades.goldBonus) {
                        goldReward = Math.floor(goldReward * 1.2);
                    }
                    
                    gameState.gold += goldReward;
                    gameState.research += researchReward;
                    gameState.score += this.reward * 3;
                    gameState.totalKills++;
                    
                    if (tower) {
                        tower.kills++;
                    }
                    
                    // ì½¤ë³´ ì¦ê°€
                    gameState.combo++;
                    gameState.comboTimer = 300; // 5ì´ˆ
                    if (gameState.combo > gameState.maxCombo) {
                        gameState.maxCombo = gameState.combo;
                    }
                    
                    this.remove();
                    
                    // í­ë°œ íš¨ê³¼
                    for (let i = 0; i < 12; i++) {
                        particles.push(new Particle(this.x, this.y, this.type));
                    }
                    
                    playSound(600 + Math.random() * 400, 0.2, 'square', 0.05);
                    
                    // ë„ì „ê³¼ì œ í™•ì¸
                    checkAchievements();
                }
            }
            
            applySlow(effect, duration) {
                this.speed = this.baseSpeed * effect;
                this.slowTimer = duration;
                if (effect <= 0.1) {
                    this.frozen = true;
                }
            }
            
            remove() {
                let index = enemies.indexOf(this);
                if (index > -1) {
                    enemies.splice(index, 1);
                }
            }
            
            draw() {
                // ì  ë³¸ì²´
                let color = this.type === 'strong' ? '#ff6b6b' : 
                           this.type === 'fast' ? '#4ecdc4' :
                           this.type === 'boss' ? '#7209b7' :
                           this.type === 'shielded' ? '#feca57' :
                           this.type === 'flying' ? '#a8e6cf' : '#ff9f43';
                
                if (this.frozen) {
                    color = '#87ceeb';
                }
                
                // ë¹„í–‰ ìœ ë‹› ê·¸ë¦¼ì
                if (this.flying) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x, this.y + this.size + 5, this.size * 0.8, this.size * 0.4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y - (this.flying ? 10 : 0), this.size, 0, Math.PI * 2);
                ctx.fill();
                
                // ë³´ìŠ¤ íŠ¹ë³„ íš¨ê³¼
                if (this.type === 'boss') {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - (this.flying ? 10 : 0), this.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }
                
                // ì‰´ë“œ í‘œì‹œ
                if (this.shield > 0) {
                    ctx.strokeStyle = '#00bfff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - (this.flying ? 10 : 0), this.size + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.lineWidth = 1;
                }
                
                // HP ë°”
                let barWidth = this.size * 2.8;
                let barHeight = 5;
                let hpPercent = this.hp / this.maxHp;
                let yOffset = this.flying ? 10 : 0;
                
                // ë°°ê²½
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 15 - yOffset, barWidth, barHeight);
                
                // HP ë°”
                ctx.fillStyle = hpPercent > 0.6 ? '#4ecdc4' : hpPercent > 0.3 ? '#feca57' : '#ff6b6b';
                ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 15 - yOffset, barWidth * hpPercent, barHeight);
                
                // ì‰´ë“œ ë°”
                if (this.maxShield > 0) {
                    let shieldPercent = this.shield / this.maxShield;
                    ctx.fillStyle = '#00bfff';
                    ctx.fillRect(this.x - barWidth / 2, this.y - this.size - 20 - yOffset, barWidth * shieldPercent, 3);
                }
                
                // ìŠ¬ë¡œìš° íš¨ê³¼ í‘œì‹œ
                if (this.slowTimer > 0 && !this.frozen) {
                    ctx.fillStyle = 'rgba(76, 201, 240, 0.3)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y - (this.flying ? 10 : 0), this.size + 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // í–¥ìƒëœ íˆ¬ì‚¬ì²´ í´ë˜ìŠ¤
        class Projectile {
            constructor(x, y, target, damage, type, tower, critical = false) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.type = type;
                this.tower = tower;
                this.critical = critical;
                this.speed = tower.projectileSpeed * gameState.gameSpeed;
                this.pierceCount = 0;
                this.hitTargets = [];
            }
            
            update() {
                if (!this.target || enemies.indexOf(this.target) === -1) {
                    if (this.type === 'laser' && this.pierceCount < this.tower.piercing) {
                        // ë ˆì´ì €ëŠ” ë‹¤ìŒ íƒ€ê²Ÿì„ ì°¾ìŒ
                        this.findNextTarget();
                    } else {
                        this.remove();
                        return;
                    }
                }
                
                if (this.target) {
                    let dx = this.target.x - this.x;
                    let dy = this.target.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 15) {
                        this.hit();
                    } else {
                        this.x += (dx / distance) * this.speed;
                        this.y += (dy / distance) * this.speed;
                    }
                }
            }
            
            findNextTarget() {
                for (let enemy of enemies) {
                    if (!this.hitTargets.includes(enemy)) {
                        let distance = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                        if (distance <= 100) {
                            this.target = enemy;
                            return;
                        }
                    }
                }
                this.remove();
            }
            
            hit() {
                if (this.type === 'splash') {
                    // ìŠ¤í”Œë˜ì‹œ ë°ë¯¸ì§€
                    for (let enemy of enemies) {
                        let distance = Math.sqrt((enemy.x - this.target.x) ** 2 + (enemy.y - this.target.y) ** 2);
                        if (distance <= this.tower.splashRadius) {
                            let splashDamage = distance <= 25 ? this.damage : this.damage * 0.6;
                            enemy.takeDamage(splashDamage, this.tower, this.critical && distance <= 25);
                        }
                    }
                    // í­ë°œ íš¨ê³¼
                    effects.push(new Explosion(this.target.x, this.target.y, this.tower.splashRadius));
                } else {
                    this.target.takeDamage(this.damage, this.tower, this.critical);
                    
                    // ë ˆì´ì € ê´€í†µ íš¨ê³¼
                    if (this.type === 'laser' && this.pierceCount < this.tower.piercing) {
                        this.hitTargets.push(this.target);
                        this.pierceCount++;
                        this.damage *= 0.8; // ê´€í†µí•  ë•Œë§ˆë‹¤ ë°ë¯¸ì§€ ê°ì†Œ
                        this.findNextTarget();
                        return;
                    }
                }
                
                // ìŠ¬ë¡œìš° íš¨ê³¼
                if (this.tower.slowEffect > 0) {
                    this.target.applySlow(this.tower.slowEffect, this.tower.slowDuration);
                }
                
                this.remove();
            }
            
            remove() {
                let index = projectiles.indexOf(this);
                if (index > -1) {
                    projectiles.splice(index, 1);
                }
            }
            
            draw() {
                let color = this.type === 'sniper' ? '#ff6b6b' :
                           this.type === 'splash' ? '#feca57' :
                           this.type === 'slow' ? '#4ecdc4' :
                           this.type === 'laser' ? '#a8e6cf' : '#feca57';
                
                if (this.critical) {
                    color = '#ffd700';
                }
                
                if (this.type === 'laser') {
                    // ë ˆì´ì € ë¹” íš¨ê³¼
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(this.tower.x, this.tower.y);
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                    ctx.lineWidth = 1;
                }
                
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.critical ? 6 : 4, 0, Math.PI * 2);
                ctx.fill();
                
                // íˆ¬ì‚¬ì²´ ê¼¬ë¦¬ íš¨ê³¼
                if (this.critical) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }
        
        // ë‚ ì”¨ íš¨ê³¼ ì‹œìŠ¤í…œ
        function updateWeather() {
            gameState.weatherTimer++;
            
            // 5ë¶„ë§ˆë‹¤ ë‚ ì”¨ ë³€ê²½
            if (gameState.weatherTimer >= 3600) {
                let weathers = ['clear', 'rain', 'storm', 'fog', 'snow'];
                gameState.weather = weathers[Math.floor(Math.random() * weathers.length)];
                gameState.weatherTimer = 0;
                
                // ë‚ ì”¨ íŒŒí‹°í´ ì´ˆê¸°í™”
                weatherParticles = [];
                for (let i = 0; i < 50; i++) {
                    weatherParticles.push(createWeatherParticle());
                }
            }
            
            // ë‚ ì”¨ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            weatherParticles.forEach(particle => {
                particle.update();
                if (particle.y > canvas.height || particle.life <= 0) {
                    let index = weatherParticles.indexOf(particle);
                    weatherParticles[index] = createWeatherParticle();
                }
            });
        }
        
        function createWeatherParticle() {
            return {
                x: Math.random() * canvas.width,
                y: -10,
                vx: (Math.random() - 0.5) * 2,
                vy: 2 + Math.random() * 3,
                life: 300,
                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.life--;
                }
            };
        }
        
        function drawWeather() {
            if (gameState.weather === 'clear') return;
            
            weatherCtx.clearRect(0, 0, weatherCanvas.width, weatherCanvas.height);
            
            weatherParticles.forEach(particle => {
                if (gameState.weather === 'rain') {
                    weatherCtx.strokeStyle = 'rgba(100, 150, 255, 0.6)';
                    weatherCtx.lineWidth = 1;
                    weatherCtx.beginPath();
                    weatherCtx.moveTo(particle.x, particle.y);
                    weatherCtx.lineTo(particle.x - particle.vx * 5, particle.y - particle.vy * 5);
                    weatherCtx.stroke();
                } else if (gameState.weather === 'snow') {
                    weatherCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    weatherCtx.beginPath();
                    weatherCtx.arc(particle.x, particle.y, 2, 0, Math.PI * 2);
                    weatherCtx.fill();
                } else if (gameState.weather === 'fog') {
                    weatherCtx.fillStyle = 'rgba(200, 200, 200, 0.1)';
                    weatherCtx.beginPath();
                    weatherCtx.arc(particle.x, particle.y, 20, 0, Math.PI * 2);
                    weatherCtx.fill();
                }
            });
        }
        
        // ì½¤ë³´ ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸
        function updateCombo() {
            if (gameState.comboTimer > 0) {
                gameState.comboTimer--;
                if (gameState.comboTimer === 0) {
                    gameState.combo = 0;
                }
            }
            
            // ì½¤ë³´ UI í‘œì‹œ
            let comboElement = document.getElementById('comboCounter');
            if (gameState.combo >= 5) {
                comboElement.style.display = 'block';
                document.getElementById('comboValue').textContent = gameState.combo;
                document.getElementById('comboBonus').textContent = Math.floor(gameState.combo / 10) * 10;
            } else {
                comboElement.style.display = 'none';
            }
        }
        
        // ë„ì „ê³¼ì œ ì‹œìŠ¤í…œ
        function checkAchievements() {
            gameState.achievementsList.forEach(achievement => {
                if (achievement.unlocked) return;
                
                let unlock = false;
                switch (achievement.id) {
                    case 'firstTower':
                        unlock = gameState.towersBuilt >= 1;
                        break;
                    case 'wave10':
                        unlock = gameState.wave >= 10;
                        break;
                    case 'combo50':
                        unlock = gameState.maxCombo >= 50;
                        break;
                    case 'kill1000':
                        unlock = gameState.totalKills >= 1000;
                        break;
                    case 'noLife':
                        unlock = gameState.wave >= 5 && gameState.lives === 30;
                        break;
                }
                
                if (unlock) {
                    achievement.unlocked = true;
                    gameState.achievements++;
                    showAchievement(achievement);
                    playSound(1500, 0.8, 'sine');
                }
            });
        }
        
        function showAchievement(achievement) {
            let notification = document.getElementById('achievementNotification');
            notification.innerHTML = `
                <div style="font-size: 18px;">ğŸ† ë„ì „ê³¼ì œ ë‹¬ì„±!</div>
                <div style="font-size: 14px; margin-top: 5px;">${achievement.name}</div>
                <div style="font-size: 12px; opacity: 0.8;">${achievement.desc}</div>
            `;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }
        
        // ì—°êµ¬ ì‹œìŠ¤í…œ (ìˆ˜ì •ë¨)
        function buyResearch(type) {
            const costs = {
                goldBonus: 500,
                moreLife: 400,
                towerDamage: 600,
                towerSpeed: 600
            };
            
            // gameState.researchëŠ” ì—°êµ¬ í¬ì¸íŠ¸ë¥¼ ì €ì¥í•˜ëŠ” ìˆ«ìê°’
            // gameState.researchUpgradesëŠ” ì—…ê·¸ë ˆì´ë“œ ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” ê°ì²´
            if (!gameState.researchUpgrades) {
                gameState.researchUpgrades = {
                    goldBonus: false,
                    moreLife: false,
                    towerDamage: false,
                    towerSpeed: false
                };
            }
            
            if (gameState.research >= costs[type] && !gameState.researchUpgrades[type]) {
                gameState.research -= costs[type];
                gameState.researchUpgrades[type] = true;
                
                // ì¦‰ì‹œ íš¨ê³¼ ì ìš©
                if (type === 'moreLife') {
                    gameState.lives += 10;
                } else if (type === 'towerDamage') {
                    towers.forEach(tower => tower.damage *= 1.25);
                } else if (type === 'towerSpeed') {
                    towers.forEach(tower => tower.fireRate *= 0.7);
                }
                
                document.getElementById(type + 'Btn').disabled = true;
                document.getElementById(type + 'Btn').textContent = 'êµ¬ë§¤ì™„ë£Œ';
                document.getElementById(type + 'Btn').style.background = '#555';
                playSound(1200, 0.5, 'sine');
            }
        }
        
        // ê²Œì„ ì†ë„ ì¡°ì ˆ
        function setGameSpeed(speed) {
            gameState.gameSpeed = speed;
            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.style.background = 'linear-gradient(45deg, #7209b7, #4cc9f0)';
            });
            event.target.style.background = 'linear-gradient(45deg, #4ecdc4, #44bd87)';
        }
        
        // ë¯¸ë‹ˆë§µ ê·¸ë¦¬ê¸°
        function drawMiniMap() {
            miniMapCtx.clearRect(0, 0, 120, 80);
            
            // ë°°ê²½
            miniMapCtx.fillStyle = 'rgba(22, 33, 62, 0.8)';
            miniMapCtx.fillRect(0, 0, 120, 80);
            
            // ê²½ë¡œ
            miniMapCtx.strokeStyle = '#4cc9f0';
            miniMapCtx.lineWidth = 2;
            miniMapCtx.beginPath();
            for (let i = 0; i < path.length; i++) {
                let x = (path[i].x / canvas.width) * 120;
                let y = (path[i].y / canvas.height) * 80;
                if (i === 0) {
                    miniMapCtx.moveTo(x, y);
                } else {
                    miniMapCtx.lineTo(x, y);
                }
            }
            miniMapCtx.stroke();
            
            // íƒ€ì›Œë“¤
            towers.forEach(tower => {
                let x = (tower.x / canvas.width) * 120;
                let y = (tower.y / canvas.height) * 80;
                miniMapCtx.fillStyle = tower.color;
                miniMapCtx.fillRect(x - 1, y - 1, 2, 2);
            });
            
            // ì ë“¤
            enemies.forEach(enemy => {
                let x = (enemy.x / canvas.width) * 120;
                let y = (enemy.y / canvas.height) * 80;
                miniMapCtx.fillStyle = enemy.type === 'boss' ? '#ff0000' : '#ff9f43';
                miniMapCtx.fillRect(x - 0.5, y - 0.5, 1, 1);
            });
        }
        
        // ë°°ê²½ ë‚˜ë¬´ë“¤ ìƒì„±
        let backgroundTrees = [];
        
        function generateBackgroundTrees() {
            backgroundTrees = [];
            
            // ë§µ ì „ì²´ì— ë‚˜ë¬´ë“¤ì„ ëœë¤í•˜ê²Œ ë°°ì¹˜
            for (let i = 0; i < 40; i++) {
                let x = Math.random() * canvas.width;
                let y = Math.random() * canvas.height;
                
                // ê²½ë¡œì™€ ë„ˆë¬´ ê°€ê¹ì§€ ì•Šì€ ê³³ì—ë§Œ ë°°ì¹˜
                let tooClose = false;
                for (let j = 0; j < path.length - 1; j++) {
                    let p1 = path[j];
                    let p2 = path[j + 1];
                    let distance = distanceToLine(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (distance < 60) {
                        tooClose = true;
                        break;
                    }
                }
                
                // ì‹œì‘ì ê³¼ ëì ì—ì„œë„ ì¶©ë¶„íˆ ë–¨ì–´ëœ¨ë¦¬ê¸°
                if (Math.sqrt((x - path[0].x) ** 2 + (y - path[0].y) ** 2) < 70 ||
                    Math.sqrt((x - path[path.length - 1].x) ** 2 + (y - path[path.length - 1].y) ** 2) < 70) {
                    tooClose = true;
                }
                
                if (!tooClose) {
                    backgroundTrees.push({
                        x: x,
                        y: y,
                        size: 20 + Math.random() * 25,
                        type: Math.random() < 0.7 ? 'tree' : 'bush',
                        sway: Math.random() * Math.PI * 2, // ë‚˜ë¬´ í”ë“¤ë¦¼ ì• ë‹ˆë©”ì´ì…˜ìš©
                        swaySpeed: 0.02 + Math.random() * 0.03
                    });
                }
            }
        }
        
        // ë§µ í…Œë§ˆì— ë§ëŠ” ë‚˜ë¬´ ìƒì„± (ê°œì„ ë¨)
        function generateBackgroundTrees() {
            backgroundTrees = [];
            let theme = mapThemes[currentMap];
            
            // ë§µë³„ë¡œ ë‹¤ë¥¸ ìˆ˜ì˜ ë‚˜ë¬´ ìƒì„±
            for (let i = 0; i < theme.treeCount; i++) {
                let x = Math.random() * canvas.width;
                let y = Math.random() * canvas.height;
                
                // ê²½ë¡œì™€ ë„ˆë¬´ ê°€ê¹ì§€ ì•Šì€ ê³³ì—ë§Œ ë°°ì¹˜
                let tooClose = false;
                for (let j = 0; j < path.length - 1; j++) {
                    let p1 = path[j];
                    let p2 = path[j + 1];
                    let distance = distanceToLine(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (distance < 60) {
                        tooClose = true;
                        break;
                    }
                }
                
                // ì‹œì‘ì ê³¼ ëì ì—ì„œë„ ì¶©ë¶„íˆ ë–¨ì–´ëœ¨ë¦¬ê¸°
                if (Math.sqrt((x - path[0].x) ** 2 + (y - path[0].y) ** 2) < 70 ||
                    Math.sqrt((x - path[path.length - 1].x) ** 2 + (y - path[path.length - 1].y) ** 2) < 70) {
                    tooClose = true;
                }
                
                if (!tooClose) {
                    backgroundTrees.push({
                        x: x,
                        y: y,
                        size: 15 + Math.random() * 30,
                        type: theme.treeTypes[Math.floor(Math.random() * theme.treeTypes.length)],
                        color: theme.treeColors[Math.floor(Math.random() * theme.treeColors.length)],
                        sway: Math.random() * Math.PI * 2,
                        swaySpeed: 0.01 + Math.random() * 0.02
                    });
                }
            }
        }
        
        // í…Œë§ˆë³„ ë‚˜ë¬´ ê·¸ë¦¬ê¸° (ëŒ€í­ í™•ì¥)
        function drawBackgroundTrees() {
            backgroundTrees.forEach(tree => {
                tree.sway += tree.swaySpeed;
                let swayOffset = Math.sin(tree.sway) * 1.5;
                
                // ê·¸ë¦¼ì (ëª¨ë“  íƒ€ì… ê³µí†µ)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.ellipse(tree.x, tree.y + tree.size * 0.7, tree.size * 0.5, tree.size * 0.15, 0, 0, Math.PI * 2);
                ctx.fill();
                
                switch(tree.type) {
                    case 'tree': // ì¼ë°˜ ë‚˜ë¬´ (ìˆ²)
                        // ì¤„ê¸°
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(tree.x - 3 + swayOffset, tree.y - tree.size * 0.3, 6, tree.size * 0.7);
                        
                        // ìì‚¬ê·€
                        ctx.fillStyle = tree.color;
                        ctx.beginPath();
                        ctx.arc(tree.x + swayOffset, tree.y - tree.size * 0.5, tree.size * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'bush': // ë¤ë¶ˆ
                        ctx.fillStyle = tree.color;
                        for (let i = 0; i < 3; i++) {
                            let offsetX = (i - 1) * tree.size * 0.15;
                            ctx.beginPath();
                            ctx.arc(tree.x + offsetX + swayOffset * 0.5, tree.y - i * 3, tree.size * 0.25, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'cactus': // ì„ ì¸ì¥ (ì‚¬ë§‰)
                        ctx.fillStyle = tree.color;
                        // ë©”ì¸ ê¸°ë‘¥
                        ctx.fillRect(tree.x - 6, tree.y - tree.size * 0.8, 12, tree.size * 0.8);
                        // ê°€ì§€ë“¤
                        if (tree.size > 25) {
                            ctx.fillRect(tree.x - 20, tree.y - tree.size * 0.5, 8, tree.size * 0.3);
                            ctx.fillRect(tree.x + 12, tree.y - tree.size * 0.6, 8, tree.size * 0.4);
                        }
                        // ê°€ì‹œ
                        ctx.fillStyle = '#654321';
                        for (let i = 0; i < 5; i++) {
                            ctx.fillRect(tree.x - 2, tree.y - tree.size * 0.8 + i * tree.size * 0.15, 4, 2);
                        }
                        break;
                        
                    case 'rock': // ë°”ìœ„ (ì‚¬ë§‰/ì‚°ì•…)
                        ctx.fillStyle = tree.color;
                        ctx.beginPath();
                        ctx.arc(tree.x, tree.y, tree.size * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        // ì‘ì€ ë°”ìœ„ë“¤
                        ctx.beginPath();
                        ctx.arc(tree.x - tree.size * 0.2, tree.y + tree.size * 0.1, tree.size * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(tree.x + tree.size * 0.15, tree.y - tree.size * 0.1, tree.size * 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'pine': // ì†Œë‚˜ë¬´ (ì‚°ì•…)
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(tree.x - 2 + swayOffset, tree.y - tree.size * 0.2, 4, tree.size * 0.6);
                        
                        ctx.fillStyle = tree.color;
                        // ì‚¼ê°í˜• ëª¨ì–‘ ë‚˜ë¬´
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(tree.x + swayOffset, tree.y - tree.size * 0.8 + i * tree.size * 0.2);
                            ctx.lineTo(tree.x - tree.size * 0.3 + swayOffset, tree.y - tree.size * 0.4 + i * tree.size * 0.2);
                            ctx.lineTo(tree.x + tree.size * 0.3 + swayOffset, tree.y - tree.size * 0.4 + i * tree.size * 0.2);
                            ctx.closePath();
                            ctx.fill();
                        }
                        break;
                        
                    case 'swamptree': // ëŠªì§€ ë‚˜ë¬´
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(tree.x - 4 + swayOffset, tree.y - tree.size * 0.4, 8, tree.size * 0.8);
                        
                        ctx.fillStyle = tree.color;
                        // ì¶• ëŠ˜ì–´ì§„ ê°€ì§€ë“¤
                        ctx.beginPath();
                        ctx.arc(tree.x + swayOffset, tree.y - tree.size * 0.6, tree.size * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ëŠ˜ì–´ì§„ ì´ë¼
                        ctx.strokeStyle = tree.color;
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 3; i++) {
                            ctx.beginPath();
                            ctx.moveTo(tree.x + (i - 1) * 10 + swayOffset, tree.y - tree.size * 0.3);
                            ctx.lineTo(tree.x + (i - 1) * 8 + swayOffset * 2, tree.y - tree.size * 0.1);
                            ctx.stroke();
                        }
                        ctx.lineWidth = 1;
                        break;
                        
                    case 'icetree': // ì–¼ìŒ ë‚˜ë¬´
                        ctx.fillStyle = '#87ceeb';
                        ctx.fillRect(tree.x - 3 + swayOffset * 0.3, tree.y - tree.size * 0.3, 6, tree.size * 0.7);
                        
                        ctx.fillStyle = tree.color;
                        ctx.beginPath();
                        ctx.arc(tree.x + swayOffset * 0.3, tree.y - tree.size * 0.5, tree.size * 0.35, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ì–¼ìŒ ê²°ì •
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(tree.x - 5 + swayOffset * 0.3, tree.y - tree.size * 0.5);
                        ctx.lineTo(tree.x + 5 + swayOffset * 0.3, tree.y - tree.size * 0.5);
                        ctx.moveTo(tree.x + swayOffset * 0.3, tree.y - tree.size * 0.5 - 5);
                        ctx.lineTo(tree.x + swayOffset * 0.3, tree.y - tree.size * 0.5 + 5);
                        ctx.stroke();
                        break;
                        
                    case 'crystal': // í¬ë¦¬ìŠ¤í„¸ (ì–¼ìŒ)
                        ctx.fillStyle = tree.color;
                        ctx.beginPath();
                        ctx.moveTo(tree.x, tree.y - tree.size * 0.6);
                        ctx.lineTo(tree.x - tree.size * 0.2, tree.y);
                        ctx.lineTo(tree.x + tree.size * 0.2, tree.y);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.strokeStyle = '#ffffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        break;
                }
                
                // ì¥ì‹ ìš”ì†Œ (ê½ƒ, ì—´ë§¤ ë“±)
                if (Math.random() < 0.2) {
                    let decorColor = currentMap === 'desert' ? '#FF4500' :
                                   currentMap === 'ice' ? '#ffffff' :
                                   currentMap === 'swamp' ? '#9400d3' : '#FF69B4';
                    ctx.fillStyle = decorColor;
                    ctx.beginPath();
                    ctx.arc(tree.x + (Math.random() - 0.5) * tree.size * 0.5 + swayOffset, 
                            tree.y - tree.size * 0.4 + (Math.random() - 0.5) * tree.size * 0.3, 
                            1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }
        canvas.addEventListener('mousemove', (e) => {
            let rect = canvas.getBoundingClientRect();
            mousePos = {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        });
        
        function getMousePos() {
            return mousePos;
        }
        
        // ê²½ë¡œ ê·¸ë¦¬ê¸° (ê°œì„ ë¨)
        function drawPath() {
            // ë©”ì¸ ê²½ë¡œ
            ctx.strokeStyle = 'rgba(76, 201, 240, 0.15)';
            ctx.lineWidth = 30;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            
            // ê²½ë¡œ í…Œë‘ë¦¬
            ctx.strokeStyle = 'rgba(76, 201, 240, 0.3)';
            ctx.lineWidth = 25;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            
            // ë°©í–¥ í™”ì‚´í‘œ (ë” ë§ì´)
            for (let i = 0; i < path.length - 1; i++) {
                let p1 = path[i];
                let p2 = path[i + 1];
                let segments = 3;
                
                for (let j = 1; j <= segments; j++) {
                    let t = j / (segments + 1);
                    let x = p1.x + (p2.x - p1.x) * t;
                    let y = p1.y + (p2.y - p1.y) * t;
                    
                    ctx.fillStyle = 'rgba(76, 201, 240, 0.4)';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('â†’', x, y + 5);
                }
            }
            
            // ì‹œì‘ì ê³¼ ëì  í‘œì‹œ (ê°œì„ ë¨)
            ctx.fillStyle = '#4ecdc4';
            ctx.beginPath();
            ctx.arc(path[0].x, path[0].y, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('ğŸšª', path[0].x, path[0].y + 7);
            
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(path[path.length - 1].x, path[path.length - 1].y, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.fillText('ğŸ ', path[path.length - 1].x, path[path.length - 1].y + 7);
        }
        
        // ì›¨ì´ë¸Œ ìƒì„± (ëŒ€í­ ê°œì„ )
        function generateWave(waveNumber) {
            let wave = [];
            let difficulty = Math.min(waveNumber, 20) / 20; // ìµœëŒ€ ë‚œì´ë„ ì œí•œ
            
            let basicEnemies = Math.floor(5 + waveNumber * 1.5);
            let strongEnemies = Math.floor(waveNumber > 2 ? waveNumber / 2 : 0);
            let fastEnemies = Math.floor(waveNumber > 3 ? waveNumber / 3 : 0);
            let shieldedEnemies = Math.floor(waveNumber > 5 ? waveNumber / 4 : 0);
            let flyingEnemies = Math.floor(waveNumber > 7 ? waveNumber / 5 : 0);
            let bossEnemies = Math.floor(waveNumber > 10 ? waveNumber / 8 : waveNumber > 5 ? 1 : 0);
            
            for (let i = 0; i < basicEnemies; i++) wave.push('basic');
            for (let i = 0; i < strongEnemies; i++) wave.push('strong');
            for (let i = 0; i < fastEnemies; i++) wave.push('fast');
            for (let i = 0; i < shieldedEnemies; i++) wave.push('shielded');
            for (let i = 0; i < flyingEnemies; i++) wave.push('flying');
            for (let i = 0; i < bossEnemies; i++) wave.push('boss');
            
            // ë°°ì—´ ì„ê¸°
            for (let i = wave.length - 1; i > 0; i--) {
                let j = Math.floor(Math.random() * (i + 1));
                [wave[i], wave[j]] = [wave[j], wave[i]];
            }
            
            return wave;
        }
        
        // ì›¨ì´ë¸Œ ì •ë³´ í‘œì‹œ
        function showWaveInfo() {
            let nextWave = generateWave(gameState.wave);
            let preview = {};
            
            nextWave.forEach(enemy => {
                preview[enemy] = (preview[enemy] || 0) + 1;
            });
            
            let html = '<h4>ë‹¤ìŒ ì›¨ì´ë¸Œ êµ¬ì„±:</h4>';
            html += '<div style="text-align: left;">';
            
            if (preview.basic) html += `<p>ğŸŸ  ê¸°ë³¸ ì : ${preview.basic}ë§ˆë¦¬</p>`;
            if (preview.strong) html += `<p>ğŸ”´ ê°•í™” ì : ${preview.strong}ë§ˆë¦¬</p>`;
            if (preview.fast) html += `<p>ğŸ”µ ë¹ ë¥¸ ì : ${preview.fast}ë§ˆë¦¬</p>`;
            if (preview.shielded) html += `<p>ğŸŸ¡ ì‰´ë“œ ì : ${preview.shielded}ë§ˆë¦¬</p>`;
            if (preview.flying) html += `<p>ğŸŸ¢ ë¹„í–‰ ì : ${preview.flying}ë§ˆë¦¬</p>`;
            if (preview.boss) html += `<p>ğŸŸ£ ë³´ìŠ¤: ${preview.boss}ë§ˆë¦¬</p>`;
            
            html += '</div>';
            html += `<p><strong>ì´ ${nextWave.length}ë§ˆë¦¬</strong></p>`;
            
            document.getElementById('wavePreview').innerHTML = html;
            document.getElementById('nextWaveInfo').style.display = 'block';
        }
        
        function closeWaveInfo() {
            document.getElementById('nextWaveInfo').style.display = 'none';
        }
        
        // ì›¨ì´ë¸Œ ì‹œì‘
        function startWave() {
            if (waveStarted) return;
            
            currentWave = generateWave(gameState.wave);
            waveStarted = true;
            enemiesSpawned = 0;
            spawnTimer = 0;
            
            document.getElementById('startWaveBtn').disabled = true;
            playSound(400, 0.5, 'sine');
            updateUI();
        }
        
        // ì  ìŠ¤í° (ê°œì„ ë¨)
        function spawnEnemies() {
            if (!waveStarted || enemiesSpawned >= currentWave.length) return;
            
            spawnTimer++;
            let spawnRate = Math.max(30, 60 - gameState.wave * 2); // ì›¨ì´ë¸Œê°€ ì§„í–‰ë ìˆ˜ë¡ ë¹¨ë¼ì§
            spawnRate /= gameState.gameSpeed;
            
            if (spawnTimer >= spawnRate) {
                enemies.push(new Enemy(currentWave[enemiesSpawned]));
                enemiesSpawned++;
                spawnTimer = 0;
            }
        }
        
        // ì›¨ì´ë¸Œ ì™„ë£Œ í™•ì¸
        function checkWaveComplete() {
            if (waveStarted && enemiesSpawned >= currentWave.length && enemies.length === 0) {
                gameState.wave++;
                let bonus = 50 + gameState.wave * 15;
                gameState.gold += bonus;
                gameState.score += bonus;
                gameState.research += Math.floor(gameState.wave / 2);
                waveStarted = false;
                document.getElementById('startWaveBtn').disabled = false;
                playSound(800, 1, 'sine');
                
                checkAchievements();
            }
        }
        
        // í–¥ìƒëœ ìŠ¤í‚¬ ì‹œìŠ¤í…œ
        function useSkill(skillType) {
            if (!audioContext) initAudio();
            
            const skill = gameState.skills[skillType];
            if (skill.cooldown > 0 || gameState.gold < skill.cost) return;
            
            gameState.gold -= skill.cost;
            skill.cooldown = 600; // 10ì´ˆ ì¿¨ë‹¤ìš´
            
            switch (skillType) {
                case 'bomb':
                    // ëª¨ë“  ì ì—ê²Œ ê´‘ì—­ ë°ë¯¸ì§€
                    for (let enemy of enemies) {
                        enemy.takeDamage(150, null, true);
                        for (let i = 0; i < 15; i++) {
                            particles.push(new Particle(enemy.x, enemy.y, enemy.type));
                        }
                    }
                    playSound(200, 1, 'sawtooth');
                    break;
                    
                case 'freeze':
                    // ëª¨ë“  ì ì„ 5ì´ˆê°„ ë¹™ê²°
                    for (let enemy of enemies) {
                        enemy.applySlow(0.05, 300);
                    }
                    playSound(1000, 0.8, 'sine');
                    break;
                    
                case 'boost':
                    // ëª¨ë“  íƒ€ì›Œ 5ì´ˆê°„ ê°•í™”
                    for (let tower of towers) {
                        tower.boostTimer = 300;
                    }
                    playSound(1500, 0.6, 'square');
                    break;
                    
                case 'storm':
                    // ë²ˆê°œ í­í’ - ê°€ì¥ ê°•í•œ ì ë“¤ì—ê²Œ ì¦‰ì‚¬ê¸‰ ë°ë¯¸ì§€
                    let strongestEnemies = enemies
                        .sort((a, b) => b.hp - a.hp)
                        .slice(0, Math.min(5, enemies.length));
                    
                    strongestEnemies.forEach(enemy => {
                        enemy.takeDamage(enemy.hp * 0.8, null, true);
                        effects.push(new Lightning(enemy.x, enemy.y));
                    });
                    playSound(100, 1.5, 'sawtooth');
                    break;
            }
        }
        
        // ë²ˆê°œ íš¨ê³¼ í´ë˜ìŠ¤
        class Lightning {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 20;
                this.maxLife = 20;
                this.branches = [];
                
                for (let i = 0; i < 5; i++) {
                    this.branches.push({
                        x: x + (Math.random() - 0.5) * 100,
                        y: y + (Math.random() - 0.5) * 100,
                        opacity: Math.random()
                    });
                }
            }
            
            update() {
                this.life--;
                if (this.life <= 0) {
                    let index = effects.indexOf(this);
                    if (index > -1) {
                        effects.splice(index, 1);
                    }
                }
            }
            
            draw() {
                let alpha = this.life / this.maxLife;
                ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`;
                ctx.lineWidth = 3;
                
                this.branches.forEach(branch => {
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - 50);
                    ctx.lineTo(branch.x, branch.y);
                    ctx.stroke();
                });
                
                ctx.lineWidth = 1;
            }
        }
        
        // í–¥ìƒëœ íŒŒí‹°í´ í´ë˜ìŠ¤
        class Particle {
            constructor(x, y, type = 'basic') {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 50;
                this.maxLife = 50;
                this.size = 2 + Math.random() * 3;
                this.color = type === 'boss' ? '#7209b7' :
                            type === 'strong' ? '#ff6b6b' :
                            type === 'fast' ? '#4ecdc4' :
                            type === 'shielded' ? '#feca57' :
                            type === 'flying' ? '#a8e6cf' : '#ff9f43';
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.life--;
                
                if (this.life <= 0) {
                    let index = particles.indexOf(this);
                    if (index > -1) {
                        particles.splice(index, 1);
                    }
                }
            }
            
            draw() {
                let alpha = this.life / this.maxLife;
                ctx.fillStyle = this.color.includes('rgb') ? 
                    this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba') :
                    `rgba(255, 159, 67, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // í­ë°œ íš¨ê³¼ í´ë˜ìŠ¤ (ê°œì„ ë¨)
        class Explosion {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.life = 40;
                this.maxLife = 40;
            }
            
            update() {
                this.life--;
                if (this.life <= 0) {
                    let index = effects.indexOf(this);
                    if (index > -1) {
                        effects.splice(index, 1);
                    }
                }
            }
            
            draw() {
                let alpha = this.life / this.maxLife;
                let currentRadius = this.radius * (1.2 - alpha);
                
                // ì™¸ë¶€ ë§
                ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.4})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // ì¤‘ê°„ ë§
                ctx.fillStyle = `rgba(255, 150, 0, ${alpha * 0.6})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                // ë‚´ë¶€ ì½”ì–´
                ctx.fillStyle = `rgba(255, 255, 150, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, currentRadius * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ìŠ¤í‚¬ ì¿¨ë‹¤ìš´ ì—…ë°ì´íŠ¸
        function updateSkills() {
            for (let skillName in gameState.skills) {
                let skill = gameState.skills[skillName];
                if (skill.cooldown > 0) {
                    skill.cooldown -= gameState.gameSpeed;
                    let element = document.getElementById(skillName + 'Cooldown');
                    if (skill.cooldown > 0) {
                        element.style.display = 'flex';
                        element.textContent = Math.ceil(skill.cooldown / 60);
                    } else {
                        element.style.display = 'none';
                    }
                }
            }
        }
        
        // UI ì—…ë°ì´íŠ¸ (ê°œì„ ë¨)
        function updateUI() {
            document.getElementById('gold').textContent = gameState.gold;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('research').textContent = gameState.research;
            document.getElementById('achievements').textContent = gameState.achievements;
            document.getElementById('enemiesLeft').textContent = waveStarted ? 
                currentWave.length - enemiesSpawned + enemies.length : 0;
                
            // íƒ€ì›Œ ë²„íŠ¼ í™œì„±í™”/ë¹„í™œì„±í™”
            document.querySelector('.basic-tower').style.opacity = gameState.gold >= 30 ? '1' : '0.5';
            document.querySelector('.sniper-tower').style.opacity = gameState.gold >= 60 ? '1' : '0.5';
            document.querySelector('.splash-tower').style.opacity = gameState.gold >= 80 ? '1' : '0.5';
            document.querySelector('.slow-tower').style.opacity = gameState.gold >= 50 ? '1' : '0.5';
            document.querySelector('.laser-tower').style.opacity = gameState.gold >= 120 ? '1' : '0.5';
            
            // ì—°êµ¬ ë²„íŠ¼ ì—…ë°ì´íŠ¸ (ìˆ˜ì •ë¨)
            ['goldBonus', 'moreLife', 'towerDamage', 'towerSpeed'].forEach(researchType => {
                let btn = document.getElementById(researchType + 'Btn');
                if (btn && gameState.researchUpgrades && !gameState.researchUpgrades[researchType]) {
                    let cost = researchType === 'goldBonus' ? 500 : 
                              researchType === 'moreLife' ? 400 :
                              researchType === 'towerDamage' ? 600 : 600;
                    btn.disabled = gameState.research < cost;
                    btn.style.opacity = gameState.research >= cost ? '1' : '0.5';
                }
            });
        }
        
        // íƒ€ì›Œ ì„ íƒ
        function selectTower(type) {
            if (gameState.gold < towerTypes[type].cost) return;
            
            gameState.selectedTool = gameState.selectedTool === type ? null : type;
            gameState.selectedTower = null;
            
            // ë²„íŠ¼ ì„ íƒ ìƒíƒœ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
            if (gameState.selectedTool) {
                document.querySelector(`.${type}-tower`).classList.add('selected');
            }
            
            closeTowerInfo();
        }
        
        // íƒ€ì›Œ ì •ë³´ì°½ í‘œì‹œ (ê°œì„ ë¨)
        function showTowerInfo(tower) {
            gameState.selectedTower = tower;
            const towerData = towerTypes[tower.type];
            
            document.getElementById('towerTitle').textContent = `${towerData.name} (ë ˆë²¨ ${tower.level})`;
            
            let stats = `
                <div style="text-align: left;">
                <p>ğŸ’¥ ë°ë¯¸ì§€: ${Math.round(tower.damage)}</p>
                <p>ğŸ¯ ì‚¬ê±°ë¦¬: ${tower.range}</p>
                <p>âš¡ ê³µê²©ì†ë„: ${(60/tower.fireRate).toFixed(1)}/ì´ˆ</p>
                <p>ğŸ† ì²˜ì¹˜ìˆ˜: ${tower.kills}ë§ˆë¦¬</p>
                <p>ğŸ“Š ì´ ë°ë¯¸ì§€: ${Math.round(tower.totalDamage)}</p>
                ${tower.splashRadius ? `<p>ğŸ’¥ ìŠ¤í”Œë˜ì‹œ: ${tower.splashRadius}</p>` : ''}
                ${tower.slowEffect ? `<p>ğŸ§Š ìŠ¬ë¡œìš°: ${Math.round((1-tower.slowEffect)*100)}%</p>` : ''}
                ${tower.piercing ? `<p>âš¡ ê´€í†µ: ${tower.piercing}íšŒ</p>` : ''}
                <p>ğŸ’° íŒë§¤ê°€: ${tower.getSellValue()}G</p>
                </div>
            `;
            document.getElementById('towerStats').innerHTML = stats;
            
            let upgrades = '';
            if (tower.level <= towerData.upgrades.length) {
                const upgrade = towerData.upgrades[tower.level - 1];
                upgrades = `<button class="upgrade-btn" onclick="upgradeTower()" ${gameState.gold < upgrade.cost ? 'disabled' : ''}>
                    ì—…ê·¸ë ˆì´ë“œ (${upgrade.cost}G)
                </button>`;
            } else {
                upgrades = '<p style="color: #ffd700;">â­ ìµœëŒ€ ë ˆë²¨! â­</p>';
            }
            document.getElementById('towerUpgrades').innerHTML = upgrades;
            
            document.getElementById('towerInfo').style.display = 'block';
        }
        
        // íƒ€ì›Œ ì •ë³´ì°½ ë‹«ê¸°
        function closeTowerInfo() {
            document.getElementById('towerInfo').style.display = 'none';
            gameState.selectedTower = null;
        }
        
        // íƒ€ì›Œ ì—…ê·¸ë ˆì´ë“œ
        function upgradeTower() {
            if (gameState.selectedTower && gameState.selectedTower.upgrade()) {
                showTowerInfo(gameState.selectedTower);
                playSound(1200, 0.3, 'sine');
            }
        }
        
        // íƒ€ì›Œ íŒë§¤
        function sellTower() {
            if (gameState.selectedTower) {
                gameState.gold += gameState.selectedTower.getSellValue();
                let index = towers.indexOf(gameState.selectedTower);
                if (index > -1) {
                    towers.splice(index, 1);
                }
                closeTowerInfo();
                playSound(600, 0.3, 'triangle');
            }
        }
        
        // ê²Œì„ ì¼ì‹œì •ì§€
        function pauseGame() {
            gameState.paused = !gameState.paused;
            let btn = event.target;
            btn.textContent = gameState.paused ? 'ê³„ì†í•˜ê¸°' : 'ì¼ì‹œì •ì§€';
        }
        
        // ê²Œì„ ì˜¤ë²„ (ê°œì„ ë¨)
        function endGame(victory = false) {
            gameState.gameOver = true;
            
            let finalStats = `
                <div style="text-align: left; margin: 15px 0;">
                <h4>ìµœì¢… í†µê³„:</h4>
                <p>ğŸŒŠ ë„ë‹¬ ì›¨ì´ë¸Œ: ${gameState.wave}</p>
                <p>ğŸ‘¹ ì´ ì²˜ì¹˜: ${gameState.totalKills}ë§ˆë¦¬</p>
                <p>ğŸ’¥ ì´ ë°ë¯¸ì§€: ${Math.round(gameState.totalDamage)}</p>
                <p>ğŸ° ê±´ì„¤í•œ íƒ€ì›Œ: ${gameState.towersBuilt}ê°œ</p>
                <p>ğŸ”¥ ìµœê³  ì½¤ë³´: ${gameState.maxCombo}</p>
                <p>ğŸ† ë„ì „ê³¼ì œ: ${gameState.achievements}ê°œ</p>
                </div>
            `;
            
            document.getElementById('finalStats').innerHTML = finalStats;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('gameOverTitle').textContent = victory ? 'ğŸ‰ ìŠ¹ë¦¬!' : 'ğŸ’€ ê²Œì„ ì˜¤ë²„!';
            document.getElementById('gameOverMessage').textContent = 
                victory ? `ëŒ€ë‹¨í•©ë‹ˆë‹¤! ì›¨ì´ë¸Œ ${gameState.wave}ê¹Œì§€ ì„±ê³µí–ˆìŠµë‹ˆë‹¤!` : 
                `ê¸°ì§€ê°€ í•¨ë½ë˜ì—ˆìŠµë‹ˆë‹¤. ì›¨ì´ë¸Œ ${gameState.wave}ì—ì„œ ê²Œì„ ì¢…ë£Œ.`;
        }
        
        // ê²Œì„ ì¬ì‹œì‘ (ì—°êµ¬ ì‹œìŠ¤í…œ ìˆ˜ì •)
        function restartGame() {
            gameState = {
                gold: 200,
                lives: 30,
                wave: 1,
                score: 0,
                research: 0, // ì—°êµ¬ í¬ì¸íŠ¸ ë¦¬ì…‹
                achievements: 0,
                selectedTool: null,
                selectedTower: null,
                paused: false,
                gameOver: false,
                gameSpeed: 1,
                combo: 0,
                maxCombo: 0,
                comboTimer: 0,
                weather: 'clear',
                weatherTimer: 0,
                totalKills: 0,
                totalDamage: 0,
                towersBuilt: 0,
                skills: {
                    bomb: { cooldown: 0, cost: 100 },
                    freeze: { cooldown: 0, cost: 80 },
                    boost: { cooldown: 0, cost: 60 },
                    storm: { cooldown: 0, cost: 150 }
                },
                researchUpgrades: { // ì—°êµ¬ ì—…ê·¸ë ˆì´ë“œ ìƒíƒœ ë¦¬ì…‹
                    goldBonus: false,
                    moreLife: false,
                    towerDamage: false,
                    towerSpeed: false
                },
                achievementsList: [
                    { id: 'firstTower', name: 'ì²« íƒ€ì›Œ', desc: 'íƒ€ì›Œë¥¼ ì²˜ìŒ ê±´ì„¤í•˜ì„¸ìš”', unlocked: false },
                    { id: 'wave10', name: 'ìƒì¡´ì', desc: 'ì›¨ì´ë¸Œ 10ì— ë„ë‹¬í•˜ì„¸ìš”', unlocked: false },
                    { id: 'combo50', name: 'ì½¤ë³´ ë§ˆìŠ¤í„°', desc: '50 ì½¤ë³´ë¥¼ ë‹¬ì„±í•˜ì„¸ìš”', unlocked: false },
                    { id: 'kill1000', name: 'í•™ì‚´ì', desc: 'ì  1000ë§ˆë¦¬ë¥¼ ì²˜ì¹˜í•˜ì„¸ìš”', unlocked: false },
                    { id: 'noLife', name: 'ì™„ë²½í•œ ë°©ì–´', desc: 'ë¼ì´í”„ë¥¼ í•˜ë‚˜ë„ ìƒì§€ ì•Šê³  ì›¨ì´ë¸Œ 5ë¥¼ í´ë¦¬ì–´í•˜ì„¸ìš”', unlocked: false }
                ]
            };
            
            towers = [];
            enemies = [];
            projectiles = [];
            particles = [];
            effects = [];
            damageNumbers = [];
            weatherParticles = [];
            waveStarted = false;
            enemiesSpawned = 0;
            
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('startWaveBtn').disabled = false;
            document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
            document.querySelectorAll('.speed-btn')[1].click(); // 1x ì†ë„ë¡œ ë¦¬ì…‹
            closeTowerInfo();
            closeWaveInfo();
            
            // ì—°êµ¬ ë²„íŠ¼ ë¦¬ì…‹ (ìˆ˜ì •ë¨)
            ['goldBonus', 'moreLife', 'towerDamage', 'towerSpeed'].forEach(researchType => {
                let btn = document.getElementById(researchType + 'Btn');
                if (btn) {
                    btn.disabled = false;
                    btn.style.background = 'linear-gradient(45deg, #7209b7, #4cc9f0)';
                    btn.style.opacity = '0.5';
                    
                    // ì›ë˜ ë¹„ìš©ìœ¼ë¡œ í…ìŠ¤íŠ¸ ë³µì›
                    let cost = researchType === 'goldBonus' ? '500ğŸ’' : 
                              researchType === 'moreLife' ? '400ğŸ’' :
                              researchType === 'towerDamage' ? '600ğŸ’' : '600ğŸ’';
                    btn.textContent = cost;
                }
            });
            
            // ë°°ê²½ ë‚˜ë¬´ë“¤ ë‹¤ì‹œ ìƒì„±
            generateBackgroundTrees();
        }
        
        // ì ê³¼ ì„ ë¶„ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
        function distanceToLine(px, py, x1, y1, x2, y2) {
            let A = px - x1;
            let B = py - y1;
            let C = x2 - x1;
            let D = y2 - y1;
            
            let dot = A * C + B * D;
            let lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            
            let xx, yy;
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            let dx = px - xx;
            let dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // ë§ˆìš°ìŠ¤ í´ë¦­ ì²˜ë¦¬ (ëŒ€í­ ê°œì„ )
        canvas.addEventListener('click', (e) => {
            if (gameState.gameOver || gameState.paused) return;
            
            let rect = canvas.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            
            // íƒ€ì›Œ í´ë¦­ í™•ì¸
            for (let tower of towers) {
                if (Math.sqrt((tower.x - x) ** 2 + (tower.y - y) ** 2) < 25) {
                    showTowerInfo(tower);
                    gameState.selectedTool = null;
                    document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
                    return;
                }
            }
            
            // íƒ€ì›Œ ë°°ì¹˜
            if (gameState.selectedTool && towerTypes[gameState.selectedTool]) {
                const towerType = towerTypes[gameState.selectedTool];
                if (gameState.gold >= towerType.cost) {
                    // íƒ€ì›Œ ë°°ì¹˜ ê°€ëŠ¥í•œ ìœ„ì¹˜ì¸ì§€ í™•ì¸
                    let canPlace = true;
                    let reason = '';
                    
                    // ë‹¤ë¥¸ íƒ€ì›Œì™€ ë„ˆë¬´ ê°€ê¹ì§€ ì•Šì€ì§€ í™•ì¸
                    for (let tower of towers) {
                        if (Math.sqrt((tower.x - x) ** 2 + (tower.y - y) ** 2) < 55) {
                            canPlace = false;
                            reason = 'ë‹¤ë¥¸ íƒ€ì›Œì™€ ë„ˆë¬´ ê°€ê¹ìŠµë‹ˆë‹¤';
                            break;
                        }
                    }
                    
                    // ê²½ë¡œ ìœ„ê°€ ì•„ë‹Œì§€ í™•ì¸
                    if (canPlace) {
                        for (let i = 0; i < path.length - 1; i++) {
                            let p1 = path[i];
                            let p2 = path[i + 1];
                            let distance = distanceToLine(x, y, p1.x, p1.y, p2.x, p2.y);
                            if (distance < 40) {
                                canPlace = false;
                                reason = 'ê²½ë¡œ ìœ„ì—ëŠ” ê±´ì„¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                                break;
                            }
                        }
                    }
                    
                    // ë§µ ê²½ê³„ í™•ì¸
                    if (canPlace && (x < 30 || x > canvas.width - 30 || y < 30 || y > canvas.height - 30)) {
                        canPlace = false;
                        reason = 'ë§µ ê²½ê³„ì—ëŠ” ê±´ì„¤í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                    }
                    
                    if (canPlace) {
                        towers.push(new Tower(x, y, gameState.selectedTool));
                        gameState.gold -= towerType.cost;
                        gameState.towersBuilt++;
                        gameState.selectedTool = null;
                        document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
                        playSound(800, 0.2, 'triangle');
                        
                        checkAchievements();
                    } else {
                        // ë°°ì¹˜ ë¶ˆê°€ í”¼ë“œë°±
                        playSound(150, 0.3, 'sawtooth');
                    }
                }
            } else {
                closeTowerInfo();
            }
        });
        
        // ê²Œì„ ë£¨í”„ (ìµœì¢… ì™„ì„±)
        function gameLoop() {
            if (!gameState.paused && !gameState.gameOver) {
                // ì  ìŠ¤í°
                spawnEnemies();
                
                // ëª¨ë“  ê°ì²´ ì—…ë°ì´íŠ¸
                towers.forEach(tower => tower.update());
                enemies.forEach(enemy => enemy.update());
                projectiles.forEach(projectile => projectile.update());
                particles.forEach(particle => particle.update());
                effects.forEach(effect => effect.update());
                damageNumbers.forEach(damage => damage.update());
                
                // ì‹œìŠ¤í…œ ì—…ë°ì´íŠ¸
                updateSkills();
                updateCombo();
                updateWeather();
                
                // ì›¨ì´ë¸Œ ì™„ë£Œ í™•ì¸
                checkWaveComplete();
                
                // ê²Œì„ ì˜¤ë²„ í™•ì¸
                if (gameState.lives <= 0) {
                    endGame(false);
                }
                
                // ìŠ¹ë¦¬ ì¡°ê±´ (ì›¨ì´ë¸Œ 50 í´ë¦¬ì–´)
                if (gameState.wave > 50) {
                    endGame(true);
                }
            }
            
            // í™”ë©´ ê·¸ë¦¬ê¸°
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ë°°ê²½ ë‚˜ë¬´ë“¤ ë¨¼ì € ê·¸ë¦¬ê¸° (ë‹¤ë¥¸ ìš”ì†Œë“¤ ë’¤ì—)
            drawBackgroundTrees();
            
            drawPath();
            towers.forEach(tower => tower.draw());
            enemies.forEach(enemy => enemy.draw());
            projectiles.forEach(projectile => projectile.draw());
            particles.forEach(particle => particle.draw());
            effects.forEach(effect => effect.draw());
            damageNumbers.forEach(damage => damage.draw());
            
            // ë‚ ì”¨ íš¨ê³¼ ê·¸ë¦¬ê¸°
            drawWeather();
            
            // ë¯¸ë‹ˆë§µ ê·¸ë¦¬ê¸°
            drawMiniMap();
            
            updateUI();
            requestAnimationFrame(gameLoop);
        }
        
        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤ (í™•ì¥)
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver) return;
            
            switch(e.key) {
                case '1': selectTower('basic'); break;
                case '2': selectTower('sniper'); break;
                case '3': selectTower('splash'); break;
                case '4': selectTower('slow'); break;
                case '5': selectTower('laser'); break;
                case ' ': 
                    e.preventDefault(); 
                    pauseGame(); 
                    break;
                case 'Enter': 
                    e.preventDefault();
                    if (!waveStarted) startWave(); 
                    break;
                case 'Escape': 
                    gameState.selectedTool = null;
                    document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
                    closeTowerInfo();
                    closeWaveInfo();
                    break;
                case 'q': useSkill('bomb'); break;
                case 'w': useSkill('freeze'); break;
                case 'e': useSkill('boost'); break;
                case 'r': useSkill('storm'); break;
                case 'i': showWaveInfo(); break;
                case 'p': setGameSpeed(gameState.gameSpeed === 1 ? 2 : 1); break;
            }
        });
        
        // í„°ì¹˜ ì§€ì› (ê°œì„ )
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            let touch = e.touches[0];
            let rect = canvas.getBoundingClientRect();
            let clickEvent = new MouseEvent('click', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(clickEvent);
        });
        
        
        // ì°½ í¬ê¸° ë³€ê²½ ì‹œ ìº”ë²„ìŠ¤ ì¡°ì •
        window.addEventListener('resize', () => {
            // ë°˜ì‘í˜• ì²˜ë¦¬ í•„ìš”ì‹œ ì—¬ê¸°ì— ì¶”ê°€
        });
        
        // ê²Œì„ ì‹œì‘ ì•ˆë‚´
        function showGameInstructions() {
            console.log(`
ğŸ® íƒ€ì›Œ ë””íœìŠ¤ ULTIMATE ì¡°ì‘ë²•:

ğŸ° íƒ€ì›Œ ê±´ì„¤:
- 1-5 í‚¤: íƒ€ì›Œ íƒ€ì… ì„ íƒ
- ë§ˆìš°ìŠ¤ í´ë¦­: íƒ€ì›Œ ë°°ì¹˜
- íƒ€ì›Œ í´ë¦­: ì •ë³´/ì—…ê·¸ë ˆì´ë“œ

âš¡ ìŠ¤í‚¬:
- Q: í­íƒ„ (ëª¨ë“  ì ì—ê²Œ ë°ë¯¸ì§€)
- W: ë¹™ê²° (ëª¨ë“  ì  ë™ê²°)
- E: ê°•í™” (íƒ€ì›Œ ë¶€ìŠ¤íŠ¸)
- R: ë²ˆê°œ í­í’ (ê°•ì  ì²˜ì¹˜)

ğŸ® ê²Œì„ ì œì–´:
- ìŠ¤í˜ì´ìŠ¤: ì¼ì‹œì •ì§€
- ì—”í„°: ì›¨ì´ë¸Œ ì‹œì‘
- ESC: ì„ íƒ ì·¨ì†Œ
- I: ì›¨ì´ë¸Œ ì •ë³´
- P: ì†ë„ ì „í™˜ (1x/2x)
- ë§ˆìš°ìŠ¤ íœ : ì†ë„ ì¡°ì ˆ

ğŸ† ëª©í‘œ: ì›¨ì´ë¸Œ 50ê¹Œì§€ ìƒì¡´í•˜ì„¸ìš”!
            `);
        }
        
        // ê²Œì„ ì‹œì‘
        initAudio();
        showGameInstructions();
        
        // ë°°ê²½ ë‚˜ë¬´ë“¤ ìƒì„±
        generateBackgroundTrees();
        
        // ì´ˆê¸° ë‚ ì”¨ íŒŒí‹°í´ ìƒì„±
        for (let i = 0; i < 30; i++) {
            weatherParticles.push(createWeatherParticle());
        }
        
        gameLoop();
    </script>
</body>
</html>
